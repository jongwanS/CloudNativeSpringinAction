# 1. 클라우드 네티이브 소개
- **클라우드 네이티브 애플리케이션**은 **클라우드에서 실행되면서 변화에 탄력적으로 대응하고 고도로 분산되어 있는 시스템**이다.
- 시스템은 여러 개의 서비스로 구성되며 **이 서비스들은 네트워크를 통해 서로 통신**한다.
- [그림1.1]은 클라우드 네이티브 시스템을 정의하기 위해 필요한 모든 요소를 개괄적으로 보여준다.

![1](./images/ch1/img.png)    
출처 : 클라우드 네이티브 스프링 인 액션  
## 1.1 클라우드 네이티브란 무엇인가?
- 클라우드 업계의 베테랑인 `폴 프리맨틀`
  - 클라우드 네이티브라는 용어를 처음으로 사용
- 기존 애플리케이션을 클라우드로 옮기는 것을 `리프트 및 시프트(lift and shift)`접근 방식이라고 부르는데 이러한 방식은 **애플리케이션이 클라우드 네이티브가 되는 것은 아니다.**
  - 어떻게 하는 것이 클라우드 네이티브 일까?

## 1.1.1 클라우드 네이티브에서의 세가지 P
- `애플리케이션이 클라우드를 위해 특별히 설계`된다는 것은 `무엇을 의미`할까?
- 클라우드 네이티브 컴퓨팅 재단(cloud native computing foundation, CNCF)은 **클라우드 네이티브에 대해 정의**를 했다.
- **3가지 P**
  - `플랫폼(platform)` : 클라우드 네이티브 애플리케이션은 **클라우드(공용, 사설 또는 하이브리드) 같은 같은 동적 분산 환경을 기반으로 하는 플랫폼에서 실행 된다.**
  - `속성(property)` : 클라우드 네이티브 애플리케이션은 **확장 가능**, **느슨하게 결합**, **복원력**이 뛰어나고, **관리가 용이**하며 **관찰 가능하도록 설계** 된다.
  - `실행(practice)` : **견고한 자동화**를 통해 빈번하고 **예측 가능한 방식으로 시스템을 변경하는 것이 포함**된다.(`자동화`, `지속적 전달`, `데브옵스`)

## 1.2 클라우드와 클라우드 컴퓨팅 모델
![1](./images/ch1/img1.png)    
출처 : 클라우드 네이티브 스프링 인 액션  
- 클라우드는 컴퓨팅 자원을 소비자에게 제공하는 IT 인프라이다.
  - 소비자 입장에서는 서버 하드웨어나 네트워크와 같은 **물리적 자원에 대해 신경 쓸 필요가 없다.**
  - **필요에 따라 리소스를 제공**받거나 **확장**이 가능한 온디맨드 셀프 서비스를 통해 컴퓨팅 자원을 얻을 수 있다.
- **전통적인 IT 인프라로는 탄력성을 제공할 수 없다.**
- **클라우드 컴퓨팅 모델**을 사용하면 **실제로 사용하는 것에 대해서만 비용을 지불**하면 된다.
  - 이 모델에서 `탄력성(elasticity)`은 주요 특징 중 하나다.
  - `컴퓨팅 자원`은 필요에 따라 **동적으로 더 많이 제공하거나 회수**할 수 있다.
- 클라우드 서비스를 제공하기 위한 몇가지 배포 모델이 존재한다.
  - **사설 클라우드** : 한 단체나 조직에서만 사용하도록 제공하는 클라우드 인프라이다.
  - **공공 클라우드** : 일반 사용자들에게 공공으로 제공되는 클라우드 인프라이다.
  - **하이브리드 클라우드** : 사설 클라우드 + 공공 클라우드 인프라이다.

#### [클라우드 컴퓨팅팅 서비스모델]
![1](./images/ch1/img2.png)    
출처 : 클라우드 네이티브 스프링 인 액션  

### 1.2.1 서비스형 인프라스트럭처
- 서비스형 인프라스트럭처(**IaaS**)는 `서버 & 스토리지 & 네트워크 자원을 제어하고 제공`한다.
  - aws ec2, 애저 가상 머신, 구글 컴퓨트 엔진
### 1.2.2 서비스형 컨테이너
- 서비스형 컨테이너(**CaaS**)는 `컨테이너를 만들고 관리`한다.
- 컨테이너 관리 도구
  - 도커 스웜, 아파치 메소스, **쿠버네티스**
- CaaS의 표준 쿠버네티스
  - EKS(아마존), AKS(애저), GKE(구글), ACK(알리바바), 디지털오션 쿠버네티스
### 1.2.3 서비스형 플랫폼
- 서비스형 플랫폼(**PaaS**) **클라우드 공급자가 인프라, 도구, API를 제공**하고, 이를 사용해 애플리케이션을 빌드&배포 한다.
  - AWS 빈스토크, 히로쿠, 애저 앱 서비스 등등...
### 1.2.4 서비스형 함수
- 서비스형 함수(**FaaS**) 모델의 서버리스 컴퓨팅을 사용하면 사용자는 함수의 형태로 자신의 애플리케이션의 비지니스 로직을 구현하며, 플랫폼은 서버&인프라를 제공한다.
  - HTTP 요청 또는 메시지와 같은 이벤트가 발생하면 실해오디게 할 수 있다.
  - AWS 람다, 애저 함수, 구글 클라우드 함수 등이 있다.
  - 오픈소스 진영에는 **Knative**, 아파치 오픈휘스크(Apache OpenWhisk)가 있다.
### 1.2.5 서비스형 소프트웨어
- **가장 추상화된 서비스**는 서비스형 소프트웨어(**SaaS**) 다.
- `소비자`는 사용자로서 애플리케이션에 액세스 하고 `클라우드 공급자`는 소프트웨어 & 인프라 스택 전체를 관리한다.
- SaaS의 예시로는 깃허브, 마이크로서프트 365가 있다.

## 1.3 클라우드 네이티브 애플리케이션의 특성
- CNCF는 클라우드 네이티브 애플리케이션이 가져야 할 **다섯 가지 주요 속성을 정의**한다
> **클라우드 네이티브 속성 5가지**
> - 확장성 : 워크로드의 증가 또는 감소를 동적지원  
> - 느슨한 결합 : 각각의 구성 요소들은 서로에 대해 최소한의 지식만 갖음  
> - 회복성 : 문제 직면 시 서비스 수준 유지
> - 유지 보수성 : 외부에서의 제어 수준 : 갱신, 설정, 배포
> - 관측 가능성 : 내부 상태에 대해 외부로부터 추정된 지식

![1](./images/ch1/img3.png)    
출처 : 클라우드 네이티브 스프링 인 액션  
## 1.3.1 확장성
- 수직적 확장(vertical scalability)
  - CPU나 메모리와 같은 컴퓨팅 리소스를 추가하거나 제거하는 것을 의미한다.
  - 리소스를 무한정으로 추가할 수없다.
- 수평적 확장(horizontal scalability)
  - 노드나 컨테이너를 추가하는 것을 의미한다.

 ![1](./images/ch1/img4.png)    
출처 : 클라우드 네이티브 스프링 인 액션    

- **클라우드에서는 수평적 확장을 선호**한다.
- **클라우드는 탄력적** 이기 때문에 짧은 시간에 동적으로 애플리케이션 인스턴스를 늘리거나 줄일 수 있다.
- `확장할 수 있는 애플리케이션을 설계`하는 것은 **개발자로서의 책임**이다.
  - 확장성의 큰 장애물은 애플리케이션 상태이다.
  - 상태를 갖는지(stateful), 상태를 갖지 않는지(stateless) 문제로 귀결돈다.
  - 이 책에서는 **상태를 갖지 않는 애플리케이션을 작성**하고 **문제없이 확장**할 수 있는 기법에대해 다룬다.

## 1.3.2 느슨한 결합
- `느슨한 결합` : **각 컴포넌트들이 다른 컴포넌트에 대한 지식을 가지고 있지 않은 시스템**
- **느슨한 결합(coupling)**과 **높은 응집력(cohension)**으로 **모듈화를 적절하게 달성하는 것을 목표**로 해야 한다.

- 모듈화의 세 가지 이점(파르나스, Parnas)
  - `관리` : **각 모듈이 느슨하게 결합**, 팀은 서로 간의 **의사소통에 많은 시간을 할애할 필요가 없다.**
  - `제품 유연성` : 각 모듈은 독립적으로 진화하기 때문에, **전체 시스템은 유연**하다.
  - `이해력` : **하나의 모듈만 이해하고 작업**
 
- 책 전반에 걸쳐 애플리케이션에서 `느슨한 결합을 구현하는 기법`을 살펴본다.

## 1.3.3 복원력
- **복원력(resilience)** 는 허용 가능한 수준의 서비스를 제공하고 유지할 수 있도록 하는 기능이다.
- `클라우드 네이티브 시스템 구축`시, 장애가 발생하더라도 **애플리케이션은 언제나 사용할 수 있도록 보장하는 것을 목표**로 해야 한다.
- 과거에는 결함을 예외적 상황으로 간주하였지만, `클라우드 네이티브 시스템`에서는 예외적으로 발생하는 것이 아니라 **일어날 수 밖에 없는 법칙**처럼 생각해야 한다.

- 복원력에 관한 세 가지 필수적인 개념
  - `결함(fault)` : 소프트웨어 또는 인프라에서 **잘못된 내부 상태**를 생성하는 고장
  - `오류(error)` : 예상하는 작동과 시스템이 실제 보이는 작동 간의 불일치
  - `실패(failure)` : 시스템이 응답하지 않거나 요구사양에 따라 작동하지 못하게 되는 경우이다.
 
- 결함 -> 오류 -> 실패로 확장되어 연쇄적으로 이어질 수 있기 때문에 **내결함성(fault tolerant)을 갖도록 설계** 해야 한다.
- 한 부분에서 실패가 일어나더라도 시스템의 다른 구성 요소에 영향을 끼치지 않아야 하고, **실패가 발생한 부분이 해결이 될 떄 까지 격리되어야 한다.**
- 시스템은 `자가 수리(self-repairging)` , `자가 치유(self-healing)`되는 것이 바람직하며, **클라우드 모델은 이것을 가능하게 한다.**
  - **서킷 브레이커**(circuit breaker)
  - **재시도**(retires)
  - **타임아웃**(timeout)
  - **사용률 제한**(rate limit)
## 1.3.4 관측 가능성
- **관측 가능성(observability)은** 그 시스템의 `외부 출력`에서 `내부 상태`를 **얼마나 잘 추론할 수 있는지를 측정**하는 것이다.
  - **외부 출력**은 `측정값`(metirc), `로그`(log), `트레이스`(trace)와 같은 데이터가 될 수 있다.
 ![1](./images/ch1/img5.png)    
출처 : 클라우드 네이티브 스프링 인 액션  

#### [관측 가능성의 네 가지 요소]
- `모니터링`(monitoring)
  - 애플리케이션의 **전반적인 상태 정보**를 얻고 **실패를 식별**
  - ex) 스프링 부트 엑추에이터, 프로메테우스
- `경고/시각화`(alerting/visualization)
  - 애플리케이션 모니터링 동안 **오류가 식별**되면 **경고를 보낼 수 있어야**하고, 이를 처리하기 위한 조치가 이루어져야 한다.
- `인프라를 추적하는 분산 시스템`(distributed systems tracing infrastructure)
  - **분산 시스템**에서는 서로 다른 **서브시스템 사이에서 흐르는 데이터를 추적하는 것이 필수적**이다.
  - `오픈텔레메트리(OpenTelemetry)`, `그라파냐 템포(Grafana Tempo)`를 사용해 **트레이스를 수집 및 시각화**
- `로그 집계/분석`(log aggregation/analytics)
  - 애플리케이션의 **이벤트를 추적**하는 것은 **작동을 추론하고 문제 발생 시 디버깅 하기 위해 중요한 작업**이다.
  - `플루언트 비트(Fluent Bit)`, `로키(Loki)`, `그라파냐`를 사용해 **로그를 수집 및 시각화**하고 클라우드 네이티브 환경에서 로깅을 위한 최상의 방법을 배울 것이다.
  
## 1.3.5 관리 용이성
- `관리 용이성`은 **외부 입력이 시스템의 상태 및 출력**을 `얼마나 쉽고 효율적으로 변경`할 수 있는지에 대한 것이다.
- **즉, 관리용이성이란 코드를 바꾸지 않고도 애플리케이션의 작동을 수정할 수 있는 능력이다.**
  - `유지 보수성과의 다른점`은 코드 변경을 통해 얼마나 쉽고 효율적으로 변경할 수 있는지에 관한것이다.
  - `관리 용이성`의 한 측면으로 전체 시스템을 계속 실행하며, 동시에 애플리케이션을 배포하고 업데이트 하는 것이다.
- `관리 용이성`의 또다른 요소는 설정(configuration)이다.
  - 코드를 변경하거나 새로운 릴리스를 빌드하지 않고도 시스템의 작동을 수정할 수 있도록 설정하는 것이 바람직하다.
  - ex) 데이터소스URL, 유저&패스워드, 인증서, 기능 플래그(feature flag)
  - k8s 컨피그맵(ConfigMap), 시크릿(secret), 커스터마이즈(Kustomize)등을 사용해 애플리케이션 설정을 변경할 수 있다.
- `관리 용이성`은 그 변경을 얼마나 쉽고 효율적으로 할 수 있는가에 관한 것이며, 복잡성 때문에 많은 것을 `자동화`를 통해 관리하는 것을 `목표`로 해야하며, **클라우드 네이티브의 세 가지 P중 마지막 단계인 실행으로 이어진다.**  
  
## 1.4 클라우드 네이티브를 지원하는 문화 및 관행
- CNCF, `강력한 자동화와 결합하면 최소한의 노력으로 큰 영향력을 끼치는 변경을 자주 그리고 예측 가능한 방식으로 수행할 수 있게 해준다.`
  - 자동화, 지속적 전달, 데브옵스

### 1.4.1 자동화
- `자동화(automation)`는 클라우드 네이티브의 핵심이다.
  - 반복적인 수동 작업을 자동화해 네이티브 애플리케이션을 빠르게 배포한다
  - 애플리케이션 구축부터 배포, 인프라, 설정 까지 자동화 할 수 있다.
  - 자동화를 통해 **더 신뢰할 수 있고 더 효율적인 결과를 얻을 수 있다.**
- **클라우드 자동화의 두 가지 중요한 범주**는 `인프라 제공` 및 `설정 관리` 이다.
  - `코드형 인프라스트럭처`(infrastructure as code)
  - `코드형 설정`(configuration as code)
- 클라우드 제공업체는 API를 제공하며 해당 API를 통해 서버, 네트워크, 스토리지를 생성할 수 있다.
  - **terraform**을 통해 `형상 관리`
  - **Ansible**와 같은 도구를 사용하면 서버&네트워크 설정할 수 있다.
- 인프라 생성&설정 관리 작업을 자동화하면 불안정하고 **신뢰성이 떨어지는 서버**, `스노플레이크 서버(Snowflak Server)`를 **생성하는 것을 피할 수 있다.**
- `자동화를 통해` **피닉스 서버**(Phoenux Server) 생성이 가능하다.
  - 모든 작업 자동화
  - 모든 변경 사항 형상관리 시스템 추적
  - 셋업 언제든지 반복 가능 서버 생성 => 극단으로 가면 **불가변 서버(immutable server)** 얻을 수 있다

> 마틴파울러, 코드형 인프라스트럭처
> - 다른 소프트웨어 시스템을 다룰 때와 동일한 방식으로 **소스 코드를 통해 컴퓨팅 및 네트워크 인프라를 정의하는 접근 방식** 이라고 정의한다.

> **NOTE**
> - 애완동물 vs 가축
> - 애완동물은 스노플레이크서버를 의미하고, 가축은 불가변 서버를 의미한다.

### 1.4.2 지속적 전달
- `지속적 전달`이란 **프로덕션 환경에 언제든지 배포할 수 있는 방식으로 구축하는 소프트웨어 개발의 한 분야**이다.
  - 지속적 전달을 통해 짧은 주기로 기능을 구현하여 언제든지 소프트웨어를 배포할 수 있다.
- `지속적 통합`(continuous integration, CI)
  - 지속적 전달의 토대가 되는 관행이다.
  - **개발자는 변경 사항을 기본 브랜치(메인 브랜치)에 지속적으로, 적어도 하루에 한 번 커밋한다.**
  - 소스는 `자동`으로 `컴파일`되고 `테스트`되며 실행 가능한 아티팩트로 패키징된다.
  - 새로운 변경이 있을때마다 **소프트웨어 상태에 대한 피드백을 빨리 얻고자 하는 의도**이다.
- `지속적 전달`(continuous delivery, CD)
  - CI를 기반으로, **기본 브랜치가 문제없이 배포 가능한 상태를 유지하도록 하는 데 중점**을 둔다.
  - **배포 유효성**을 검증하기 위해 `사용자 수락 테스트`, `성능 테스트`, `보안 테스트`, `컴플라이언스 테스트`와 같은 테스트를 거친다.
  - 지속적 전달은 **배포 파이프라인**을 통해 전체 `프로세스의 자동화를 촉진`한다.
  - 지속적 전달 vs 지속적 배포
    - `지속적 전달`은 **소프트웨어가 실제 서비스 환경에 배포될 수 있는 상태인지 확인을 필요로 한다.**
    - `지속적 배포`는 배포 파이프라인에 마지막 단계를 추가하여 변경된 사항을 프로덕션에 자동으로 배포하는것.
   
### 1.4.3 데브옵스
- `데브옵스(DevOps)`는 **클라우드 네이티브** 전환시 파악해야 할 **중요한 개념**이다.
> **켄 머그리지**, 소트웍스 수석 기술자
> - **지위**나 **배경**에 관계없이 사람들이 시스템을 구상, 개발, 배포 및 운영하기 위해 함께 **협력하는 문화**이다.
- `데브옵스`는 **문화**이며, **공통의 목표를 향해 함께 일하는 것**이다.
  - 개발자, 테스터, 운영자, 보안 전문가 등 자신의 **지위나 배경에 관계없이 아이디어를 제시 및 가치 창출**
- `데브옵스`는 기능 팀, QA팀, 운영 팀 사이의 장벽이 없음을 의미한다.
  - **애자일의 자연스러운 연장선**이다.

#### [데브옵스]
- `데브옵스`는 노옵스(NoOps)를 의미하지 않는다.
  - 개발자가 운영을 담당, 데브옵스는 **공동 작업**이다.
  - 한 팀에 두 가지 역할이 다 있어 **처음 아이디어 부터 제품 생산까지** 팀의 기술에 이바지 한다.
- `데브옵스`는 도구가 아니다.
  - **데브옵스 툴을 사용**한다고하여, **데브옵스 조직이 될 수 없다.** 툴은 데브옵스를 위해 사용될 뿐이다.
    - 도커, 앤서블, 쿠버네티스, 프로메테우스
  - **데브옵스는 하나의 문화다.**
- `데브옵스`는 자동화가 아니다.
  - 데브옵스에 자동화는 필수적이지만, 자동화가 곧 데브옵스를 의미하지는 않는다.
  - **아이디어에서 생산까지** 함께 작업하는 **개발자와 운영자에 관한 것**이다.
- `데브옵스`는 역할이 아니다.
  - 자동화 도구, 스크립팅, IT 시스템에 대한 숙련된 사람들을 보통 데브옵스라 부르지만, **데브옵스는 특정 역할이 아니다.**
- `데브옵스`는 팀이 아니다.
  - 기업이나 조직이 데브옵스 팀을 별도로 구성하는데, **데브옵스는 팀이 아니다.**

- `데브옵스`는 **개발자**와 **운영자**에게만 적용되는 것이 아니다.
- `데스옵스`는 모두 **함께 제품 수명 주기에 대한 책임**이 있으며 **지속적 전달이라는 목표**를 달성한다.
  - 테스터, 보안전문가 등등 소프트웨어에 수명 책임에 관한 다른 사람들의 역할도 포함된다.

## 1.5 클라우드가 최선의 선택인가?
- 새로운 기술이나 접근 방식에 대해 언급한다는 이유만으로 **해당 기술을 채택하고 적용**한다.
  - 시스템이 클라우드 네이티브를 통해 해결하려는 문제점을 가지고 있지 않다면, `클라우드 네이티브`는 최적의 방안이 아니다.
- 언제 `클라우드 네이티브`로 옮겨가는 것이 좋을가?

#### [클라우드 네이티브 옮겨가기 위한 고려사항]
- `속도` : 더 빠르고 유연한 배포 
- `복원력` : 가용성 및 안정성
- `확장성` : 탄력성 및 동적 확장성
- `비용` : 효율성 및 비용 최적화

### 1.5.1 속도
- 기업의 목표는 소프트웨어를 더 신속하게 출시하는 것이다.
  - **경쟁우위 차지** 
  - 적절한 시기에 출시하는 것은 `성공`과 `실패`의 **차이를 만들어 낸다.**
- **소규모의 빈번한 출시**는 **고객에게서 더 빨리 피드백**을 받을 수 있다는 것을 의미한다.
  - 피드백 루프가 짧아져, **새로운 기능과 관련된 위험이 감소**
  - 더 작은 릴리스로 **실패할 가능성 감소**

- **전통적인 개발방식**
  - 대규모 릴리스, 유연성 부족, 길게 늘어진 출시 사이클
- **클라우드 네이티브 접근방식** 
  - 자동화, 지속적 전달, 데브옵스
  - **더 빨리 진행**할 수 있고 **출시 시간을 단축**할 수 있다.

### 1.5.2 복원력
- **실패는 항상 일어난다.**
  - 실패를 예측하고 예외로 취급하던 시대는 지났다.
  - 변화는 예외가 아니라 **상수**다.
- **복원력이 좋은 시스템**
  - 잘못된 일이 발생하더라도 **서비스를 계속 제공**한다.
  - 문제해결을 위한 작업&업그레이드는 **다운타임 없이 수행**되어야 한다.
- **안정적이며, 복원력 높아야 하는 요구 사항**이라면 **클라우드 네이티브는 좋은 선택**이다.
### 1.5.3 확장성
- `탄력성`은 **부하에 따른 소프트웨어 확장**을 의미 한다.
- 앞으로 일어날 일을 **예측하는 것은 어렵다.**
  - 확장 가능한 애플리케이션을 만드는 것만으로 충분치 않다.
  - **상황에 따라 동적으로 확장**할 수 있어야 한다.
- **탄력성 확보**를 위해, `확장성 높은 클라우드 네이티브 애플리케이션`을 `클라우드`와 결합해 사용할 수 있다.
### 1.5.4 비용
- `소프트웨어 개발자로서` **비용을 고려해야 할 책임**은 있다.
  - 실제 사용한 만큼 지불
- `클라우드 네이티브 방식을 채택`하여 **비용 최적화**를 할 수 있다.
- 복원력이 높아, 다운타임 및 시스템 실패와 관련된 비용도 낮아진다.
- 느슨하게 결합되어 있기 때문에 경쟁우위를 갖을 수 있다.

> **클라우드로 옮겨갈 때 숨겨진 비용**
> - 마이그레이션 비용 고려해야 한다.
> - 직원들의 역량이 준비되지 않았을경우, 교육에 투자 및 클라우드 컨설턴트 고용해야 할 수도 있다.

## 1.6 클라우드 네이티브 구성
- 클라우드 네이티브가 곧 특정기술(MSA, 컨테이너)을 의미하는 것은 아니다.
#### [클라우드 일반적인 구성]
- `컨테이너`
  - 경량화, 독립적인 컴퓨팅 컨텍스트
- `오케스트레이션`
  - 컨테이너 스케줄링, 클러스터 관리
- `서버리스 및 함수`(Faas)
  - 클라우드 플랫폼에서 관리되는 서비스

- 이책에서는 **스프링 네이티브**(Spring Native), **스프링 클라우드 함수**(Spring Cloud Funtion)을 사용해, 애플리케이션 구축 방법을 다룬다.

### 1.6.1 컨테이너
- 애플리케이션은 특정 환경에서 실행되도록 작성되어 있다.
- **모든 환경을 가능한 비슷하게 유지**하는 것이 중요하다.
  - 이 부분이 **컨테이너가 필요한 지점**이다.
- 컨테이너 이전에는 `환경 재구축`, `가상 컴퓨터(vmware)`에 의존했다.
- `컨테이너`는 애플리케이션 실행을 위한 모든것을 가지고 있다.
  - 호스트OS와 **커널을 공유**
  - **네임스페이스** : 프로세스 간 `리소스 분할`
  - **c그룹** : 프로세스 `리소스 사용  제어하고 제한`
- `클라우드 네이티브` 에서 **컨테이너는 왜 인기가 많을까?**
  - 민첩성, 이식성, 배포 반속성이 뛰어나다.
  - 매우 가볍고, 리소스를 덜 사용하기 때문에 **확장성**이 좋다.
- `가상화`와 `컨테이너`는 **상호 배타적인 관계가 아니다.**
  - 가상 머신 위에 컨테이너 실행
  - IaaS 역시 가상화 계층을 제공 한다.

- 이책에서는 CNCF 프로젝트인 **클라우드 네이티브 빌드팩**을 사용해 **스프링 애플리케이션을 컨테이너**화 방법에 대해 배운다.
  
### 1.6.2 오케스트레이션
- 수십 또는 수백 개의 컨테이너를 여러 대의 서버에 배포하고 처리하려면 관리할 도구가 필요하다.
- CaaS 관점에서, `배포 대상`은 더 이상 하나의 서버가 아니라 **여러 서버로 이루어진 클러스터가** 된다.
- `컨테이너 오케스트레이션`은 **다양한 작업을 자동화** 해준다.
  - 머신을 생성 및 삭제
  - cpu 및 메모리 스케줄링 및 배포
  - 컨테이너를 동적으로 확장, 상태 모니터링
  - 컨테이너 간 네트워크 설정, 라우팅, 서비스 검색, 로드 밸런싱 정의
  - 보안 및 액세스 제어
  - 서비스 노출, 포트 및 네트워크 구축
  - 컨테이너에 자원 할당
- `오케스트레이션` 툴에 대한 명령은 **선언적**이다.
  - `yaml 파일`을 **통해 수행**된다.
- `오케스트레이터` 종류
  - 쿠버네티스, 도커 스웜, 아파치 메소스

### 1.6.3 서버리스
- 서버리스 컴퓨팅 모델을 사용하면 개발자는 애플리케이션 비지니스 로직 구현에만 집중할 수 있다.
- `서버리스 아키텍처`는 **두 가지 모델**로 나뉜다.
  - **서비스형 백엔드**(Backend as a service, Baas)
    - 클라우드 공급자가 제공하는 타사 서비스에 의존하는 애플리케이션
    - 구글 파이퍼베이스를 사용, AWS API 게이트웨이 사용하여, rest api 제공 및 관리
  - **서비스형 함수**(Function as a service, Faas)
    - `상태가 없고` `이벤트 의해` 실행되며, `플랫폼에서 관리`하는 애플리케이션이다.
    - Faas 모델은 두 가지 유형으로 제공 된다.
      - 첫째, AWS 람다, 애저 함수 등 공급자 제공 Faas
      - 둘째, 오픈소스 프로젝트 기반 서버리스 팰랫폼 선택, **Knative**

- `서버리스 애플리케이션`은 **이벤트 기반**이며, `HTTP 요청`이나 `메시지 이벤트`가 있을때 실행된다. 
- `서버리스 애플리케이션`은 **실제 사용한 것에 대해서만 비용을 지불**한다.
  - **온디멘드**
- `서버리스 애플리케이션`은 필요한 경우에만 리소스가 제공된다.
- **처리할 것이 없으면 모든 것이 중단**된다.
  - **제로 스케일링**(scaling to zero)

## 1.7 클라우드 네이티브 애플리케이션을 위한 아키텍처
### 1.7.1 다중 계층에서 마이크로서비스 아키텍처까지 그리고 그 이후
### 1.7.2 클라우드 네이티브 애플리케이션을 위한 서비스 기반 아키텍처


## 요약



